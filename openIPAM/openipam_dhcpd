#!/usr/bin/env python3

from openipam import dhcp_server
from openipam.utilities import daemon
import multiprocessing as processing
import atexit
import ctypes

from optparse import OptionParser

# parse command line options
parser = OptionParser()
parser.add_option(
    "-v",
    "--version",
    action="store_true",
    dest="version",
    help="Print the version and exit.",
)
parser.add_option(
    "-d",
    "--daemon",
    action="store_true",
    dest="daemon",
    help="Start program as a daemon.",
    default=False,
)
parser.add_option(
    "-s",
    "--signals",
    action="store_true",
    dest="signals",
    help="Use signal processing code.",
)

parser.add_option(
    "-p",
    "--pidfile",
    action="store",
    type="string",
    dest="pidfile",
    help="Use the given filename to store the PID of the server.",
    default="/var/run/openipam/openipam_dhcpd.pid",
)

(options, args) = parser.parse_args()


def consumer(*args, **kwargs):
    libc = ctypes.CDLL("libc.so.6")
    # 1 = PR_SET_PDEATHSIG, 15 = TERM, 9 = KILL
    # Should send a KILL to this child when the parent dies
    libc.prctl(1, 9)
    dhcp_server.db_consumer(*args, **kwargs)


def start():
    # max unhandled packets = (QLEN + 1) * NUM_WORKERS
    NUM_WORKERS = 10
    QLEN = 10
    req_queues = [processing.Queue(QLEN) for i in range(NUM_WORKERS)]

    server = dhcp_server.Server(req_queues=req_queues)

    req_processes = []
    for queue in req_queues:
        process = processing.Process(
            target=consumer,
            args=(queue, server.SendPacket),
            daemon=true,
        )
        req_processes.append(process)

    while True:
        server.HandlePacket()


if __name__ == "__main__":
    # FIXME: need command-line arguments
    pidfile = "/var/run/openipam/openipam_dhcpd"
    if options.daemon:
        daemon.daemonize(start, options.pidfile)
    else:
        start()
